{"componentChunkName":"component---src-templates-blog-template-js","path":"/data-engineer-5/","result":{"data":{"cur":{"id":"c71785d7-0243-5609-ae4b-5b904776f420","html":"<h2 id=\"제-5장-빅데이터의-파이프라인\" style=\"position:relative;\"><a href=\"#%EC%A0%9C-5%EC%9E%A5-%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8\" aria-label=\"제 5장 빅데이터의 파이프라인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제 5장. 빅데이터의 파이프라인</h2>\n<p>이 장에서는 빅데이터 파이프라인을 자동화하기 위한 구조에 대해 살펴봅니다.</p>\n<br />\n<br />\n<h3 id=\"워크플로-관리\" style=\"position:relative;\"><a href=\"#%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C-%EA%B4%80%EB%A6%AC\" aria-label=\"워크플로 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>워크플로 관리</h3>\n<br />\n<ul>\n<li><strong>워크플로 관리</strong></li>\n</ul>\n<br />\n<p>정해진 업무를 원할하게 진행하기 위한 구조입니다.</p>\n<br />\n<p>워크플로 관리도구의 주요 역할은 정기적으로 태스크를 실행하고 비정상적인 상태를 감지하여 그것에 대한 해결을 돕는 것입니다</p>\n<br />\n<p>오픈 소스 워크플로 관리 도구 예</p>\n<br />\n<ul>\n<li>Airflow : <code>스크립트 형</code></li>\n<li>Azkaban : <code>선언 형</code></li>\n<li>Digdag : <code>선언 형</code></li>\n<li>Luigi : : <code>스크립트 형</code></li>\n<li>Oozie : <code>선언 형</code></li>\n</ul>\n<br />\n<ul>\n<li><strong>태스크</strong></li>\n</ul>\n<p>데이터 파이프라인의 실행 과정에서 잇달아 이루어지는 개별 처리입니다.</p>\n<br />\n<ul>\n<li><strong>선언 형</strong></li>\n</ul>\n<p>XML이나 YAML 등의 서식으로 워크플로를 기술하는 타입입니다.</p>\n<br />\n<p>미리 제공된 기능만을 사용할 수 있어 단순 반복 생성 워크플로에 최적입니다.</p>\n<br />\n<ul>\n<li><strong>스크립트 형</strong></li>\n</ul>\n<p>스크립트 언어로 워크플로를 정의</p>\n<br />\n<p>스크립트 형 도구는 유연성이 좋습니다. 태스크의 정의를 프로그래밍 할 수 있습니다.</p>\n<br />\n<p>즉 <span style='color:red; font-weight: bold;'>ETL 프로세스에서는 스크립트 형의 도구</span>, 그리고 <span style='color:red; font-weight: bold;'>SQL의 실행에 있어서는 선언형 도구를 보편적으로 사용합니다.</span></p>\n<br />\n<p>일반적으로 데이터 수집과정에서 스크립트 처리가 필요한 경우가 많기 때문입니다.</p>\n<br />\n<hr>\n<br />\n<br />\n<h3 id=\"워크플로의-오류-시-대처방법\" style=\"position:relative;\"><a href=\"#%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C%EC%9D%98-%EC%98%A4%EB%A5%98-%EC%8B%9C-%EB%8C%80%EC%B2%98%EB%B0%A9%EB%B2%95\" aria-label=\"워크플로의 오류 시 대처방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>워크플로의 오류 시 대처방법</h3>\n<br />\n<p>워크플로 관리에 있어서 <strong>복구</strong>를 전제한 태스크를 설계합니다.</p>\n<br />\n<p>실패한 태스크를 모두 기록해 나중에 재실행할 수 있도록 말이죠.</p>\n<br />\n<p><code>플로우</code>는 워크플로 관리도구에 의해 실행되는 일련의 태스크를 의미합니다.</p>\n<br />\n<p>그리고 각 플로우 실행 시에는 <code>고정 파라미터</code>가 부여되고,</p>\n<br />\n<p>이 <code>고정 파라미터</code>를 동일 플로우에 건네면 완전히 동일한 플로우가 실행됩니다.</p>\n<br />\n<p>고정 파라미터가 존재해야 <code>플로우</code>가 실패해도 재실행이 가능한 것이죠.</p>\n<br />\n<hr>\n<br />\n<ul>\n<li><strong>재시도</strong></li>\n</ul>\n<br />\n<p>여러 차례 반복하는 오류는 자동화하여 복구하고 싶을 겁니다.</p>\n<br />\n<p>하지만 재시도 횟수가 너무 적거나 혹은 너무 많은 경우 오히려 오류가 해결되지 않거나 중복되는 경우가 생깁니다.</p>\n<br />\n<p>즉, 재시도를 반복해도 문제가 없는 태스크라면 1회 혹은 2회 정도 재시도를 실행하는 것이 좋습니다.</p>\n<br />\n<ul>\n<li><strong>백필</strong></li>\n</ul>\n<br />\n<p>실패한 플로우를 복구하는 또 하나의 방법은 플로우 전체를 처음부터 다시 실행하는 것입니다. 이를 위해 <code>백필</code>의 기능을 이용할 수 있습니다.</p>\n<br />\n<p><code>백필</code>이란 파라미터에 포함된 일시를 순서대로 바꿔가며 일정 기간의 플로우를 연속해서 실행하는 구조입니다.</p>\n<br />\n<p>대규모의 백필을 실시하는 경우에는 자동적인 재시도는 무효로 하고, 오류는 모두 통지하는 편이 좋습니다. 그래야 부하를 떨어뜨릴 수 있기 때문입니다.</p>\n<br />\n<hr>\n<br />\n<h3 id=\"멱등한-조작\" style=\"position:relative;\"><a href=\"#%EB%A9%B1%EB%93%B1%ED%95%9C-%EC%A1%B0%EC%9E%91\" aria-label=\"멱등한 조작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멱등한 조작</h3>\n<br />\n<p><code style='color:#f0506e'>원자성 조작</code> : 쓰기가 필요한 수만큼 태스크를 나누는 것을 의미합니다.</p>\n<br />\n<p>워크플로 안의 태스크를 모두 원자성 있는 조작으로 구현하여 재시도의 안정성을 높일 수 있습니다.</p>\n<br />\n<p>즉, 중간에 실패하고 재시도하여 발생할 수 있는 중복을 피할 수 있다는 겁니다.</p>\n<br />\n<p>단, 태스크 구현 상의 버그 등으로 문제가 발생하면 워크플로 관리 도구가 이를 오류로 여겨 중복 문제가 발생할 수 있습니다.</p>\n<br />\n<p><code style='color:#f0506e'>멱등한 조작</code> : 동일한 태스크를 여러 번 실행해도 동일한 결과가 되도록 하는 것을 의미합니다.</p>\n<br />\n<p>예를 들어 SQL이라면 ‘테이블을 삭제한 후 다시 만들기’와 같은 것을 의미합니다.</p>\n<br />\n<p>즉, 중복을 없애기 위함인데, 각 태스크를 어떻게 멱등하게 할 지는 이용자의 책임입니다.</p>\n<br />\n<p>일반적으로 <code>추가</code> 혹은 <code>치환</code>중 하나를 실시합니다.</p>\n<br />\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DROP</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">IF</span> <span class=\"token keyword\">EXISTS</span> <span class=\"token string\">\"t1\"</span>\r\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token string\">\"t1\"</span>\r\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token string\">\"t1\"</span></code></pre></div>\n<br />\n<p>여러 번 실행해도 항상 치환이 시행되도록 설계해야 멱등한 태스크가 될 수 있습니다.</p>\n<br />\n<ul>\n<li><strong>멱등한 추가</strong></li>\n</ul>\n<br />\n<p>현실에서는 항상 멱등한 태스크를 구현할 수 없습니다.</p>\n<br />\n<p>즉, 그 날의 데이터만을 INSERT문으로 추가하고 싶은 경우에는 원자성을 갖고 실행할 순 있으나, 멱등하지는 않습니다.</p>\n<br />\n<p>과거의 모든 데이터를 치환해도 부하가 커지는 단점이 존재합니다.</p>\n<br />\n<p>이를 위해 <code style='color:#f0506e'>테이블 파티셔닝</code> 사고방식을 사용합니다.</p>\n<br />\n<p>예를 들면 1시간 마다 파티션을 분할하고, 파티션 단위로 치환하는 것입니다.</p>\n<br />\n<p>파티션의 모든 데이터를 삭제하기 위해 <code>TRUNCATE 문</code> 혹은 <code>INSERT OVERWRITE 문</code>을 사용하여 멱등성을 유지하며 보기에는 하나의 시계열 테이블에 데이터가 추가 되듯이 만들 수 있습니다.</p>\n<br />\n<p>이러한 테이블 파티셔닝의 구현은 시스템에 따라 달라지고 이에 맞추어 플로우를 조립합니다.</p>\n<br />\n<p><code>hive</code>의 경우 표준으로 파티셔닝에 대응하나, <code>Amazon Redshift</code>에서는 파티셔닝의 개념이 없어 <code>UNION ALL</code>을 사용한 뷰를 사용해야 합니다.</p>\n<br />\n<ul>\n<li><strong>원자성을 지닌 추가</strong></li>\n</ul>\n<br />\n<p>복잡한 플로우에서는 중간 테이블을 만들어 처리한 후, 마지막 목적 테이블에 한 번에 추가하는 것이 안전합니다.</p>\n<br />\n<p>중간 테이블은 매번 다시 작성하는 방식(멱등함)이고, 마지막에 목적 테이블에 한번에 작성하는 구조입니다.</p>\n<br />\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">// 중간 테이블 작성</span>\r\n<span class=\"token keyword\">DROP</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">IF</span> <span class=\"token keyword\">EXISTS</span> <span class=\"token string\">\"t1\"</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token string\">\"t1\"</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token string\">\"t1\"</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token string\">\"t1\"</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// 대상 테이블에 모아서 써넣음(추가)</span>\r\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token string\">\"target_table\"</span>\r\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token string\">\"t1\"</span></code></pre></div>\n<br />\n<br />\n<h3 id=\"워크플로-전체를-멱등으로-하기\" style=\"position:relative;\"><a href=\"#%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C-%EC%A0%84%EC%B2%B4%EB%A5%BC-%EB%A9%B1%EB%93%B1%EC%9C%BC%EB%A1%9C-%ED%95%98%EA%B8%B0\" aria-label=\"워크플로 전체를 멱등으로 하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>워크플로 전체를 멱등으로 하기</h3>\n<br />\n<p>재실행의 안전성을 높이기 위해 적어도 각 플로우가 전체로서 멱등하게 되도록 구현해야 합니다.</p>\n<br />\n<p>최종적으로 워크플로가 안정적으로 실행되는 것이 목적입니다.</p>\n<br />\n<hr>\n<br />\n<br />\n<h3 id=\"태스크-큐\" style=\"position:relative;\"><a href=\"#%ED%83%9C%EC%8A%A4%ED%81%AC-%ED%81%90\" aria-label=\"태스크 큐 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>태스크 큐</h3>\n<br />\n<p>워크플로 관리 도구에서 요구되는 다른 하나의 커다란 역할은 <strong>외부 시스템의 부하 컨트롤</strong>입니다. 자원의 소비량을 조정하여 모든 태스크가 원할하게 실행되야 하죠.</p>\n<br />\n<ul>\n<li><strong>병렬화</strong></li>\n</ul>\n<br />\n<p>이를 위해 우리는 병렬화를 먼저 생각할 수 있습니다.</p>\n<br />\n<p>만일 하나의 파일 전송을 하나의 태스크로 고려하고 8코어 서버를 이용할 수 있다고 해보면, 파일의 수만큼 태스크를 실행해야 합니다.</p>\n<br />\n<p>하지만 너무 대량의 태스크를 동시 실행하면 과부하가 걸리므로 이를 위해 사용하는 것이 <code>잡 큐(job queue)</code> 또는 <code>태스크 큐(task queue)</code>라고 불리는 구조입니다.</p>\n<br />\n<p>일단 모든 태스크가 이 큐에 저장되고 워커 프로세스가 이를 꺼내며 병렬화를 실행하는 것이죠.</p>\n<br />\n<p>그렇다면 워커의 수를 늘린다면 동시에 더 많은 태스크를 처리할 수 있을 겁니다.</p>\n<br />\n<p>하지만 우리는 이로 인해 발생하는 <code>병목 현상</code>을 무시할 수 없을 겁니다.</p>\n<br />\n<p>이로 인해 성능 향상의 한계점이나 오류가 발생합니다.</p>\n<br />\n<p>요인은 크게 <code>내부적인 요인</code>과 <code>외부적인 요인</code>으로 나뉩니다.</p>\n<br />\n<p><strong>내부적인 요인</strong></p>\n<ul>\n<li><code>CPU 사용률 100%</code> : CPU 코어 수를 늘림. 서버 증설</li>\n<li><code>메모리 부족</code>: 메모리 증설, 스왑 디스크 추가, 태스크 작게 분할</li>\n<li><code>디스크 넘침</code> : 각 태스크의 임시 파일 삭제, 디스크 증설</li>\n<li><code>디스크 I/O의 한계</code> : SSD 등의 고속 디스크 사용. 여러 디스크로 분산</li>\n<li><code>네트워크 대역의 한계</code> : 고속 네트워크 사용, 데이터 압축률 높임</li>\n<li><code>통신 오류나 타임 아웃</code> : 시스템 상의 한계, 서버 분리</li>\n</ul>\n<br />\n<p><strong>외부적인 요인</strong></p>\n<p>문제 제거가 직접적으로 어렵습니다.</p>\n<br />\n<p>예를 들면 파일 복사에서 오류가 날 때, 파일 서버 측의 성능 한계 등입니다.</p>\n<br />\n<p>즉, 워커를 오히려 줄일 필요가 있습니다.</p>\n<br />\n<p>분산 스토리지로 쓰는 빈도가 높아 오류가 발생하면 쓰기 빈도를 줄입니다.</p>\n<br />\n<br />\n<ul>\n<li><strong>태스크 수의 적정화</strong></li>\n</ul>\n<br />\n<p>사실은 하나의 파일 전송을 하나의 태스크로 고려한 것이 문제입니다.</p>\n<br />\n<p>예를 들어 태스크를 1일 단위로 나눈다면 1년 치 파일을 365개로 줄일 수 있습니다.</p>\n<br />\n<p>결과적으론 <span style='color:red; font-weight: bold;'>워크플로 관리 도구에 등록된 태스크는 모두 너무 크지도 않고, 너무 작지도 않은 적당한 크기로 분할된 다수의 태스크가 여러 워커로 부터 호출되는 상태</span>가 되야 합니다.</p>\n<br />\n<hr>\n<br />\n<br />\n<h3 id=\"배치-형의-데이터-플로우\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EC%B9%98-%ED%98%95%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%8C%EB%A1%9C%EC%9A%B0\" aria-label=\"배치 형의 데이터 플로우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배치 형의 데이터 플로우</h3>\n<br />\n<ul>\n<li><strong>데이터 플로우</strong></li>\n</ul>\n<br />\n<p>기술의 발전에 따라 <strong>다단계의 데이터 처리를 분산 시스템 내에서 실행</strong>할 수 있게 된 것</p>\n<br />\n<p>배치 처리와 스트림 처리가 하나로 통합되어 통일된 프레임워크로부터 양쪽이 모두 실행되었습니다.</p>\n<br />\n<p><strong>데이터 플로우를 위한 프레임 워크</strong></p>\n<ul>\n<li>Google Cloud Dataflow</li>\n<li>Apache Spark</li>\n<li>Apache Flink</li>\n</ul>\n<br />\n<br />\n<h3 id=\"mapreduce의-구조\" style=\"position:relative;\"><a href=\"#mapreduce%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-label=\"mapreduce의 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MapReduce의 구조</h3>\n<br />\n<p>빅데이터의 대표적인 기술이었던 <code>MapReduce</code>였으나, 이제는 과거의 기술로 간주되어 구글의 차세대 기술인 <code>MillWheel</code>이라는 프레임워크에게 밀려버렸습니다.</p>\n<br />\n<p>하지만 MapReduce 자체 기술을 접할 기회가 많기에 그 구조를 알 필요가 있습니다.</p>\n<br />\n<ol>\n<li>파일을 일정 크기로 나누어 작은 데이터인 <code>split</code>으로 만듬</li>\n<li>나눈 데이터를 읽어 컴퓨터에 <code>분산 집계(Map)</code></li>\n<li>분산된 결과를 모아 <code>전부 집계(Reduce)</code></li>\n</ol>\n<br />\n<p>나눈 <code>split</code> 데이터를 분산 집계하는 과정을 <code style='color:#f0506e'>Map</code>이라고 하고, 분산 집계된 <code>split 데이터</code>를 한번에 모아 전부 집계하는 과정을 <code style='color:#f0506e'>Reduce</code>라고 합니다.</p>\n<br />\n<p>애드 혹 데이터 분석을 위해선 지연이 적어야 하지만 MapReduce는 지연이 발생하여 적합하지 않습니다.</p>\n<br />\n<p>하지만 <span style='color:red; font-weight: bold;'>Map과 Reduce를 반복한다.</span> 라는 사고 방식은 아직까지 유효합니다.</p>\n<br />\n<br />\n<h3 id=\"dag에-의한-내부-표현\" style=\"position:relative;\"><a href=\"#dag%EC%97%90-%EC%9D%98%ED%95%9C-%EB%82%B4%EB%B6%80-%ED%91%9C%ED%98%84\" aria-label=\"dag에 의한 내부 표현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DAG에 의한 내부 표현</h3>\n<br />\n<p><code style='color:#f0506e'>DAG(directed acyclic graph)</code>, 방향성 비순환 그래프라고 불리는 이 프레임워크는 MapReduce를 대신합니다.</p>\n<br />\n<p>DAG는 어떤 기술이 아니라 수학과 컴퓨터 알고리즘에 사용되는 데이터 모델의 하나 입니다.</p>\n<br />\n<ul>\n<li>노드와 노드가 화살표로 연결된다.(방향성)</li>\n<li>화살표를 아무리 따라가도 동일 노드로는 되돌아 오지 않는다.(비순환)</li>\n</ul>\n<br />\n<p>쉽게 말해 <span style='color:red; font-weight: bold;'>방향성을 지니고, 동일 노드로 돌아오지 않는(비순환) 그래프</span>라고 할 수 있습니다.</p>\n<br />\n<p>MapReduce도 Map과 Reduce라는 두 종류의 노드로 구성된 DAG라고 할 수 있습니다.</p>\n<br />\n<p>하지만 하나의 처리가 끝나기 전까지는 다음 처리를 진행할 수 없죠.</p>\n<br />\n<p>한편, 데이터 플로우에서 <span style='color:red; font-weight: bold;'>DAG를 구성하는 각 노드가 모두 동시 병행으로 실행됩니다.</span></p>\n<br />\n<p>즉, 대기 시간을 없앨 수 있다는 겁니다!</p>\n<br />\n<br />\n<h3 id=\"spark에-있어서의-dag\" style=\"position:relative;\"><a href=\"#spark%EC%97%90-%EC%9E%88%EC%96%B4%EC%84%9C%EC%9D%98-dag\" aria-label=\"spark에 있어서의 dag permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spark에 있어서의 DAG</h3>\n<br />\n<p>Spark와 같은 데이터 플로우 프레임워크에서는 프로그래밍 언어를 사용하여 직접 DAG의 데이터 구조를 조립합니다.</p>\n<br />\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 파일로부터 데이터를 읽음</span>\r\nlines <span class=\"token operator\">=</span> sc<span class=\"token punctuation\">.</span>textFile<span class=\"token punctuation\">(</span><span class=\"token string\">\"sample.txt\"</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\"># 파일의 각 행을 단어로 분해</span>\r\nwords <span class=\"token operator\">=</span> lines<span class=\"token punctuation\">.</span>flatMap<span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> line<span class=\"token punctuation\">:</span> line<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\"># 단어마다 카운터를 파일로 출력</span>\r\nwords<span class=\"token punctuation\">.</span><span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> word<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \\\r\n    <span class=\"token punctuation\">.</span>reduceByKey<span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> a<span class=\"token operator\">+</span>b<span class=\"token punctuation\">)</span> \\\r\n    <span class=\"token punctuation\">.</span>saveAsTextFile<span class=\"token punctuation\">(</span><span class=\"token string\">\"word_counts\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<br />\n<p>위 파이썬 스크립트는 Spark에서 데이터 처리를 하는 예입니다.</p>\n<br />\n<p>데이터 파이프라인 전체를 DAG로 조립하고, 실행으로 옮겨 내부 스케줄러가 시스템에 효과적인 실행 계획을 세워줍니다.</p>\n<br />\n<br />\n<h3 id=\"데이터-플로우와-워크플로의-조합\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%8C%EB%A1%9C%EC%9A%B0%EC%99%80-%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C%EC%9D%98-%EC%A1%B0%ED%95%A9\" aria-label=\"데이터 플로우와 워크플로의 조합 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 플로우와 워크플로의 조합</h3>\n<br />\n<ul>\n<li><strong>데이터를 읽어들이는 플로우</strong></li>\n</ul>\n<br />\n<p>직접 데이터 소스에 액세스하면 성능 문제를 일으키기 쉽습니다.</p>\n<br />\n<p>따라서 <span style='color:red; font-weight: bold;'>분산 스토리지에 복사함으로써 안정적으로 사용</span>할 수 있도록 합니다.</p>\n<br />\n<ul>\n<li><strong>데이터를 써서 내보내는 플로우</strong></li>\n</ul>\n<br />\n<p>만일 데이터의 집계 결과를 외부 시스템에 써서 내보내는 경우에는 완전히 반대입니다.</p>\n<br />\n<p>데이터 플로우 안에서 대량의 데이터를 전송하는 것은 피하는 편이 좋습니다.</p>\n<br />\n<p>즉, <span style='color:red; font-weight: bold;'>데이터 플로우의 출력이 CSV파일과 같이 취급하기 쉬운 형식(스키마리스)으로 변환하여 일단 분산 스토리지에 써넣습니다.</span></p>\n<br />\n<p>그 후에 다음 태스크를 실행하는 겁니다.</p>\n<br />\n<p>예를 들어 데이터 마트를 <code>MPP 데이터베이스</code>로 이용한다면, <code>분산 스토리지</code>로 부터 파일을 로드하는 명령을 발행할 수 있습니다.</p>\n<br />\n<br />\n<h3 id=\"데이터-플로우와-sql을-나누어-사용하기\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%8C%EB%A1%9C%EC%9A%B0%EC%99%80-sql%EC%9D%84-%EB%82%98%EB%88%84%EC%96%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"데이터 플로우와 sql을 나누어 사용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 플로우와 SQL을 나누어 사용하기</h3>\n<br />\n<ol>\n<li><strong>데이터 웨어하우스의 파이프라인</strong></li>\n</ol>\n<br />\n<p>SQL을 MPP 데이터베이스에서 실행하는 경우를 말합니다.</p>\n<br />\n<p>즉, 데이터 웨어하우스를 구축하는 경우 로드되는 데이터를 만드는 부분까지가 데이터 플로우의 역할입니다.</p>\n<br />\n<p>앞서 말했던 비구조화 데이터를 스키마리스 데이터로 가공하여 분산 스토리지에 써넣습니다. 태스크 실행과 SQL에 의한 쿼리 실행은 그 뒤에 맡깁니다.</p>\n<br />\n<ol start=\"2\">\n<li><strong>데이터 마트의 파이프라인</strong></li>\n</ol>\n<br />\n<p>쿼리 엔진을 이용해 데이터 마트를 구축하는 경우, 구조화 데이터를 만드는 부분까지가 데이터 플로우의 역할입니다.</p>\n<br />\n<p>분산 스토리지 상의 데이터를 배치로 가공하여 열 지향 스토리지 형식으로 보관한 후, 쿼리 엔진을 통한 SQL 실행이나 그 결과를 데이터 마트에 써서 내보냅니다.</p>\n<br />\n<hr>\n<br />\n<p>간단하게 정리하자면,</p>\n<br />\n<p>MPP 데이터베이스에서 SQL을 실시하는 경우, 즉 데이터 웨어하우스에서 후속적으로 배치 처리(SQL 집계)를 실시하는 경우, <code style='color:#f0506e'>데이터 플로우</code>는 <code>비 구조화 데이터</code>를 <code>스키마리스 데이터</code>로 만들어 <code>분산 스토리지에 저장</code>하는 과정까지이고,</p>\n<br />\n<p>쿼리 엔진을 사용하여 데이터 마트를 구축하는 경우에 <code style='color:#f0506e'>데이터 플로우</code>는 <code>비구조화 데이터</code>에서 <code>구조화 데이터(열 지향 스토리지)</code>로 만드는 부분까지입니다. 그 후, SQL 실행이나 그 결과를 데이터 마트에 쓰는 것입니다.</p>\n<br />\n<hr>\n<br />\n<br />\n<h3 id=\"대화식-플로우\" style=\"position:relative;\"><a href=\"#%EB%8C%80%ED%99%94%EC%8B%9D-%ED%94%8C%EB%A1%9C%EC%9A%B0\" aria-label=\"대화식 플로우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대화식 플로우</h3>\n<br />\n<p>구조화 되지 않은 데이터를 애드 혹으로 분석할 때, 데이터 플로우를 사용하면 좋습니다.</p>\n<br />\n<p>스크립트 언어를 통해 데이터를 가공, 집계할 수 있습니다.</p>\n<br />\n<p>데이터 구조화가 된 이후에는 더욱 더 고속 집계가 가능하며 이는 쿼리 엔진을 통한 SQL 집계와 비교해도 손색이 없습니다.</p>\n<br />\n<p>시각화 도구와 쿼리 엔진을 직접 접속하는 경우 <code>ODBC</code>와 <code>JDBC</code> 드라이버가 사용됩니다.</p>\n<br />\n<p>하지만 안정적인 워크플로 운용을 위해서는 실적이 있는 RDB와 MPP 데이터베이스를 데이터 마트로 사용하는 것이 좋습니다.</p>\n<br />\n<br />\n<h3 id=\"스트리밍-형의-데이터-플로우\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D-%ED%98%95%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%8C%EB%A1%9C%EC%9A%B0\" aria-label=\"스트리밍 형의 데이터 플로우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스트리밍 형의 데이터 플로우</h3>\n<br />\n<p>이전에는 실시간 메시지 전달 방식으로 메시지 플로우를 중심으로 하는 데이터의 흐름을 다루었습니다.</p>\n<br />\n<p>그렇게 전달 받은 데이터를 분산 스토리지에 보관하는 부분부터 시작하는 것이 <code>배치 처리</code>라고 하고,</p>\n<br />\n<p>분산 스토리지를 거치지 않고 처리를 계속하는 것이 <code style='color:#f0506e'>스트림 처리</code>라고 합니다.</p>\n<br />\n<p>배치 처리와 스트림 처리는 서로 결점을 보완하는 관계입니다.</p>\n<br />\n<p>앞으로 도달할 데이터에만 흥미가 있다면 실시간 성이 높은 스트림 처리를 하고,</p>\n<br />\n<p>과거 데이터를 집계하고 싶다면 배치 처리를 하는 쪽이 우수합니다.</p>\n<br />\n<br />\n<h3 id=\"배치-처리와-스트림-처리-통합하기\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EC%B9%98-%EC%B2%98%EB%A6%AC%EC%99%80-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%B2%98%EB%A6%AC-%ED%86%B5%ED%95%A9%ED%95%98%EA%B8%B0\" aria-label=\"배치 처리와 스트림 처리 통합하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배치 처리와 스트림 처리 통합하기</h3>\n<br />\n<ul>\n<li>배치 처리의 경우</li>\n</ul>\n<br />\n<p>먼저 데이터가 있고 그 데이터가 작게 나뉘어 DAG 안에 흘러들어옵니다.</p>\n<br />\n<p>여기서 데이터 양이 정해지는 것을 <code>유한 데이터</code>라고 합니다.</p>\n<br />\n<ul>\n<li>스트림 처리의 경우</li>\n</ul>\n<br />\n<p>끊임없이 데이터가 생성되며 그것이 DAG안에 흘러들어옵니다.</p>\n<br />\n<p>제한이 없이 데이터가 보내지는 것을 <code>무한 데이터</code>라고 합니다.</p>\n<br />\n<hr>\n<br />\n<br />\n<h3 id=\"spark-스트리밍의-dag\" style=\"position:relative;\"><a href=\"#spark-%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D%EC%9D%98-dag\" aria-label=\"spark 스트리밍의 dag permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spark 스트리밍의 DAG</h3>\n<br />\n<p>Spark는 본래 배치 처리를 위한 분산 시스템이었으나, <code>Spark 스트리밍</code>이라 불리는 기능이 통합되어 스트림 처리까지 투명하게 취급하게 되었습니다.</p>\n<br />\n<p><span style='background-color:#fff5b1'>단어를 세는 Spark 스트리밍 프로그램</span></p>\n<br />\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 1초마다 스트림 처리를 합니다.</span>\r\nsc <span class=\"token operator\">=</span> SparkContext<span class=\"token punctuation\">(</span><span class=\"token string\">\"local[2]\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"NetworkWordCount\"</span><span class=\"token punctuation\">)</span>\r\nssc <span class=\"token operator\">=</span> StreamingContext<span class=\"token punctuation\">(</span>sc<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\"># TCP 포트 9999로부터 데이터를 읽어 들입니다.</span>\r\nlines <span class=\"token operator\">=</span> ssc<span class=\"token punctuation\">.</span>socketTextStream<span class=\"token punctuation\">(</span><span class=\"token string\">\"localhost\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9999</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\"># 입력의 각 행을 단어로 분해합니다.</span>\r\nwords <span class=\"token operator\">=</span> lines<span class=\"token punctuation\">.</span>flatmap<span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> line<span class=\"token punctuation\">:</span> line<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\"># 단어별 갯수를 콘솔에 출력합니다.</span>\r\nwords<span class=\"token punctuation\">.</span><span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> word<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \\\r\n    <span class=\"token punctuation\">.</span>reduceByKey<span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> a<span class=\"token operator\">+</span>b<span class=\"token punctuation\">)</span> \\\r\n    <span class=\"token punctuation\">.</span>pprint<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\"># 스트림 처리를 시작합니다.</span>\r\nssc<span class=\"token punctuation\">.</span>start<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<br />\n<p>데이터 처리가 끝나면 종료되는 배치 처리와는 달리 스트림 처리는 프로그램을 정지할때 까지 끊임 없이 실행됩니다.</p>\n<br />\n<hr>\n<br />\n<br />\n<h3 id=\"스트림-처리의-결과를-배치-처리로-치환하기\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%B2%98%EB%A6%AC%EC%9D%98-%EA%B2%B0%EA%B3%BC%EB%A5%BC-%EB%B0%B0%EC%B9%98-%EC%B2%98%EB%A6%AC%EB%A1%9C-%EC%B9%98%ED%99%98%ED%95%98%EA%B8%B0\" aria-label=\"스트림 처리의 결과를 배치 처리로 치환하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스트림 처리의 결과를 배치 처리로 치환하기</h3>\n<br />\n<p>스트림 처리의 경우 원칙적으로 새롭게 도달한 데이터를 처리할 뿐이므로 과거의 데이터를 처리하거나, 지연에 의해 늦게 도착한 데이터를 이벤트 시간으로 집계하여 생기는 문제를 해결하기 어렵습니다.</p>\n<br />\n<p>이를 위해 배치 처리를 별개로 실행하여 이 결과를 옳다고 하는 것이 전통적인 방법입니다.</p>\n<br />\n<br />\n<h3 id=\"람다-아키텍처\" style=\"position:relative;\"><a href=\"#%EB%9E%8C%EB%8B%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98\" aria-label=\"람다 아키텍처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>람다 아키텍처</h3>\n<br />\n<p>람다 아키텍처는 이 전통적인 방법을 발전시킨 것입니다.</p>\n<br />\n<p>크게 배치 레이어, 서빙 레이어, 스피드 레이어에서 데이터를 처리합니다.</p>\n<br />\n<p><code>배치 레이어</code>에서는 대규모 배치 처리를 실시합니다. 그 후, <code>서빙 레이어</code>를 통해 접근하여 집계 결과를 추출할 수 있습니다.</p>\n<br />\n<p>여기서 얻어진 결과를 <code>배치 뷰</code>라고 하는데, 이 <code>배치 뷰</code>는 정기적으로 업데이트 되는 대신 실시간 정보를 얻을 수는 없습니다.</p>\n<br />\n<p>그래서 다른 경로로 스트림 처리를 하기 위해 <code>스피드 레이어</code>를 설치합니다.</p>\n<br />\n<p>여기서 얻은 결과를 <code>실시간 뷰</code>라고 합니다.</p>\n<br />\n<p>마지막으로 배치 뷰와 실시간 뷰를 모두 조합하는 형태로 쿼리를 실행합니다.</p>\n<br />\n<p><span style='color:red; font-weight: bold;'>최근의 집계 결과는 실시간 뷰를 참고하고 그 이전의 데이터는 배치 뷰를 사용하며 이후, 실시간 뷰의 결과는 배치 뷰로 치환됩니다.</span></p>\n<br />\n<br />\n<h3 id=\"카파-아키텍처\" style=\"position:relative;\"><a href=\"#%EC%B9%B4%ED%8C%8C-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98\" aria-label=\"카파 아키텍처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>카파 아키텍처</h3>\n<br />\n<p>람다 아키텍처의 나쁜 개발 효율이라는 문제점으로 인해 람다 아키텍처를 단순화한 카파 아키텍처를 선택할 수 있습니다.</p>\n<br />\n<p>이는 람다 아키텍처의 배치 레이어나 서빙 레이어를 완전히 제거하고, 스피드 레이어만 남겨놓습니다.</p>\n<br />\n<p>대신 메시지 브로커의 데이터 보관 기간으르 충분히 하여 문제가 발생한 경우 여기서 데이터를 다시 멱등하게 치환하도록 보냅니다.</p>\n<br />\n<p>하지만 부하가 높아지기에 계산 자원을 많이 소요하나 클라우드의 보급으로 어느정도 해결하게 되었습니다.</p>\n<br />\n<br />\n<h3 id=\"아웃-오브-오더의-데이터-처리\" style=\"position:relative;\"><a href=\"#%EC%95%84%EC%9B%83-%EC%98%A4%EB%B8%8C-%EC%98%A4%EB%8D%94%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B2%98%EB%A6%AC\" aria-label=\"아웃 오브 오더의 데이터 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아웃 오브 오더의 데이터 처리</h3>\n<br />\n<p>프로세스 시간과 이벤트 시간의 차이를 기술적으로 <code style='color:#f0506e'>아웃 오브 오더</code>의 데이터 문제라고 합니다.</p>\n<br />\n<p>하지만 결국 프로세스 시간 보다는 이벤트 시간을 집계해야 올바른 결과를 얻을 수 있기에 이를 위한 방법을 도입합니다.</p>\n<br />\n<p>스트림 처리에서 시간을 일정 간격으로 나누어 <code>윈도우</code>를 만들고 이 안에서 집계합니다.</p>\n<br />\n<p>이벤트 시간에 의해 윈도우를 나누는 것을 <code>이벤트 시간 윙도윙</code>이라고 합니다.</p>\n<br />\n<p>다만, 과거의 이벤트 데이터를 보관할 때, 무한히 보관할 수는 없으므로 일정 이상 늦게 온 데이터는 무시할 필요도 있습니다.</p>\n<br />\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 72.77777777777777%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABcklEQVQ4y22UyZLDIAxE+f/v9MFLjDe8L0w9jdtFOTkoyNBSSy2IW9c1LssSt22L+76bP8+zrXzjhxAiOL67rott28amaR4MdhyHmVuW/2BsHMfY970FKImv65hlWRxCMAyJZOHeo5jzPC2x40fViQWQ/NQI4myaJqucvWEYrAByWIXvIALSFtl7r6k13seyLI0Awq+EqWbvM+mVdkWFmMjcmxkgCdXCr6Qi1QBFbho2TWsM/c1UFIVZVVUGZKp1XZtuJMDnjDZJin4YZ9aygDBhTDltg8l/Ph9b+SYJGIiIE1aD/Gr5PXVYqRQy6YdPISn+uYe/rgaWEqgLmYan+5fiHXrkeW7a6KWk5r03zWiRBNILCSCSzjp3JEIjCY8eYQhxuvUEyB4rSSDA56XwevApiEFC5MiqW39d19OCjPP05WhfWFb9H9i1EUjv2CoMwaqVdlRDqxoGWE2XGL0S01DT1HUQUMZ+XuSmI/77nJh04n/mZ49WTOHanAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"워크플로\"\n        title=\"워크플로\"\n        src=\"/static/24c469870a9aee30ef3e6d88e6918864/37523/%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C.png\"\n        srcset=\"/static/24c469870a9aee30ef3e6d88e6918864/e9ff0/%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C.png 180w,\n/static/24c469870a9aee30ef3e6d88e6918864/f21e7/%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C.png 360w,\n/static/24c469870a9aee30ef3e6d88e6918864/37523/%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C.png 720w,\n/static/24c469870a9aee30ef3e6d88e6918864/121b3/%EC%9B%8C%ED%81%AC%ED%94%8C%EB%A1%9C.png 1070w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>","excerpt":"제 5장. 빅데이터의 파이프라인 이 장에서는 빅데이터 파이프라인을 자동화하기 위한 구조에 대해 살펴봅니다. 워크플로 관리 워크플로 관리 정해진 업무를 원할하게 진행하기 위한 구조입니다. 워크플로 관리도구의 주요 역할은 정기적으로 태스크를 실행하고 비정상적인 상태를 감지하여 그것에 대한 해결을 돕는 것입니다 오픈 소스 워크플로 관리 도구 예 Airflow : 스크립트 형 Azkaban : 선언 형 Digdag : 선언 형 Luigi : : 스크립트 형 Oozie : 선언 형 태스크 데이터 파이프라인의 실행 과정에서 잇달아 이루어지는 개별 처리입니다. 선언 형 XML이나 YAML 등의 서식으로 워크플로를 기술하는 타입입니다. 미리 제공된 기능만을 사용할 수 있어 단순 반복 생성 워크플로에 최적입니다. 스크립트 형 스크립트 언어로 워크플로를 정의 스크립트 형 도구는 유연성이 좋습니다. 태스크의 정의를 프로그래밍 할 수 있습니다. 즉 ETL 프로세스에서는 스크립트 형의 도구, 그리고 SQ…","frontmatter":{"date":"February 25, 2023","title":"빅 데이터를 지탱하는 기술 책 리뷰 - (4)","categories":"Engineer","author":"DEVEL","emoji":"🐰"},"fields":{"slug":"/data-engineer-5/"}},"next":{"id":"ae0d9aaa-2a95-51c9-bef5-c10a82fd5f13","html":"<h2 id=\"제-4장-빅데이터의-축적\" style=\"position:relative;\"><a href=\"#%EC%A0%9C-4%EC%9E%A5-%EB%B9%85%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%EC%B6%95%EC%A0%81\" aria-label=\"제 4장 빅데이터의 축적 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제 4장. 빅데이터의 축적</h2>\n<h3 id=\"객체-스토리지와-데이터-수집\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%88%98%EC%A7%91\" aria-label=\"객체 스토리지와 데이터 수집 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 스토리지와 데이터 수집</h3>\n<br />\n<p>빅데이터의 경우 확장성이 높은 <strong>분산 스토리지</strong>에 데이터 수집/저장합니다.</p>\n<br />\n<p>우선 기본이 되는 것은 <strong>객체 스토리지</strong>입니다.</p>\n<br />\n<p>대표적으로 Hadoop의 HDFS, 클라우드 서비스의 Amazon S3가 유명합니다.</p>\n<br />\n<p>이러한 객체 스토리지는 다수의 컴퓨터를 사용해 파일을 여러 디스크에 복사하여 저장합니다.</p>\n<br />\n<p>즉 중복화 및 분산/저장을 실시하나 소규모 데이터에 대해서는 통신오버헤드가 생겨 적합하지는 않죠.</p>\n<br />\n<p>객체 스토리지(분산 스토리지)안에 데이터를 기록/수집하는 것은 어느정도 노력이 필요합니다.</p>\n<br />\n<p>너무 작은 데이터는 모아서 기록하고, 너무 큰 데이터는 분할해서 기록하는 것이 집계 효율을 올리고, 문제를 예방할 수 있습니다.</p>\n<br />\n<ul>\n<li><strong>데이터 수집</strong></li>\n</ul>\n<p>수집한 데이터를 가공하여 집계 효율이 좋은 분산 스토리지를 만드는 일련의 프로세스</p>\n<br />\n<h3 id=\"벌크-형의-데이터-전송\" style=\"position:relative;\"><a href=\"#%EB%B2%8C%ED%81%AC-%ED%98%95%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%86%A1\" aria-label=\"벌크 형의 데이터 전송 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>벌크 형의 데이터 전송</h3>\n<br />\n<p>데이터 전송 구조는 벌크 형과 스트리밍 형으로 나뉩니다.</p>\n<br />\n<p>먼저 벌크 형의 데이터 전송 구조는 ETL 서버 설치로 부터 시작됩니다.</p>\n<br />\n<p>이 ETL 서버를 통해서 DB 혹은 웹 서비스로부터 수집한 데이터를 표준적인 포맷(스키마리스 데이터)으로 변환합니다.</p>\n<br />\n<p>이때 벌크 형 도구로 데이터를 보내는 경우 파일 사이즈를 적정화 해야합니다.</p>\n<br />\n<p>그렇게 하기 위해 너무 많은 양의 데이터를 전송하거나 너무 적은 양의 데이터를 전송할 때, 적당량 데이터씩 시간을 두어 전송하도록 해야합니다.</p>\n<br />\n<p>이때 워크플로 관리도구를 통해 이러한 태스크 실행을 관리할 수 있습니다.</p>\n<br />\n<h3 id=\"스트리밍-형의-데이터-전송\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D-%ED%98%95%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%86%A1\" aria-label=\"스트리밍 형의 데이터 전송 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스트리밍 형의 데이터 전송</h3>\n<br />\n<p>간단하게 말해 계속해서 전송되어 오는 작은 데이터를 취급하기 위한 데이터 전송입니다.</p>\n<br />\n<p>예를 들어 ‘웹 브라우저’, ‘모바일 앱’, ‘센서 기기’등에 해당됩니다.</p>\n<br />\n<p>이러한 경우, 데이터 전송의 공통점은 다수의 클라이언트에서 계속해서 작은 데이터가 전송된다는 겁니다.</p>\n<br />\n<p>일반적으로 이를 <strong>메시지 전송</strong>이라고 합니다.</p>\n<br />\n<p>메시지 전송을 할때는 통신 오버헤드가 커집니다. 즉, 이를 처리하는 서버 측에서 어느정도의 성능을 요구합니다.</p>\n<br />\n<p>방법은 두가지가 있습니다.</p>\n<br />\n<ol>\n<li>작은 데이터 쓰기에 적합한 NoSQL 사용</li>\n</ol>\n<br />\n<p>NoSQL 데이터베이스에 작은 데이터를 보관합니다. 이전에 말했듯이 Hive는 다른 DB로 부터 데이터를 불러들어 사용할 수 있어 Hive 쿼리 엔진을 통해 NoSQL 데이터베이스에 연결할 수 있습니다.</p>\n<br />\n<ol start=\"2\">\n<li>메시지 큐, 메시지 브로커의 사용</li>\n</ol>\n<br />\n<p>중계 시스템을 통해 일정한 간격으로 꺼내고 모아 분산 스토리지에 저장합니다.</p>\n<br />\n<h3 id=\"웹-브라우저에서의-메시지-전송\" style=\"position:relative;\"><a href=\"#%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90%EC%84%9C%EC%9D%98-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%84%EC%86%A1\" aria-label=\"웹 브라우저에서의 메시지 전송 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>웹 브라우저에서의 메시지 전송</h3>\n<br />\n<ol>\n<li>서버 상에서 데이터를 축적해 모아 보내기</li>\n</ol>\n<p>Fluentd, Logstash와 같은 서버 상주형 로그 수집 소프트웨어를 사용합니다.</p>\n<br />\n<ol start=\"2\">\n<li>웹 이벤트 트래킹</li>\n</ol>\n<p>자바스크립트를 사용해 웹 브라우저에서 직접 메시지를 보냅니다.</p>\n<br />\n<h3 id=\"모바일-앱으로부터의-메시지-전송\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%95%B1%EC%9C%BC%EB%A1%9C%EB%B6%80%ED%84%B0%EC%9D%98-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%84%EC%86%A1\" aria-label=\"모바일 앱으로부터의 메시지 전송 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모바일 앱으로부터의 메시지 전송</h3>\n<br />\n<p>통신 방법에 있어서는 웹 브라우저와 같이 HTTP 프로토콜 사용합니다.</p>\n<br />\n<ol>\n<li>MBaaS(Mobile Backend as a Service) 이용</li>\n</ol>\n<p>벡 엔드의 각종 서비스를 사용할 수 있는 MBaaS를 사용하여 수집합니다.</p>\n<br />\n<ol start=\"2\">\n<li>SDK를 사용하여 전송</li>\n</ol>\n<br />\n<h3 id=\"디바이스로부터의-메시지-전송\" style=\"position:relative;\"><a href=\"#%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4%EB%A1%9C%EB%B6%80%ED%84%B0%EC%9D%98-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%84%EC%86%A1\" aria-label=\"디바이스로부터의 메시지 전송 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>디바이스로부터의 메시지 전송</h3>\n<br />\n<p>IoT 등의 디바이스로부터 메시지 전달은 아직 업계 표준이라 할 만한 것이 없이 많은 규격이 난무합니다.</p>\n<br />\n<p>그 중에 하나로 MQTT가 있습니다.</p>\n<br />\n<p>이는 전달/구독형 메시지 전송(Pub/Sub 형 메시지 전송)으로 불립니다.</p>\n<br />\n<p>토픽이라고 불리는 방을 구독하면 그 방을 구독한 사람에게 메시지가 전달되는 형식입니다.</p>\n<br />\n<p>MQTT 브로커가 구독자인 MQTT 구독자에게 메시지를 전달하는 겁니다.</p>\n<br />\n<h3 id=\"메시지-배송의-공통화\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%8B%9C%EC%A7%80-%EB%B0%B0%EC%86%A1%EC%9D%98-%EA%B3%B5%ED%86%B5%ED%99%94\" aria-label=\"메시지 배송의 공통화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메시지 배송의 공통화</h3>\n<br />\n<p>메시지 배송 방식은 어디에서 데이터를 수집하느냐에 따라 달라집니다.</p>\n<br />\n<p>하지만 공통점은 메시지가 처음 생성되는 기기를 <strong>클라이언트</strong>, 제일 처음 메시지를 받는 서버를 <strong>프론트 엔드</strong>라고 부른다는 것.</p>\n<br />\n<p>그리고 이 프론트 엔드는 데이터 보호를 위한 일을 하며 메시지 브로커로 데이터를 전송하면 <strong>메시지 브로커</strong>가 분산 스토리지에 데이터를 저장한다는 것입니다.</p>\n<br />\n<hr>\n<h3 id=\"메시지-브로커\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%8B%9C%EC%A7%80-%EB%B8%8C%EB%A1%9C%EC%BB%A4\" aria-label=\"메시지 브로커 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메시지 브로커</h3>\n<br />\n<p>분산 스토리지에 들어오는 메시지를 마냥 기록하기만 한다면 부하 제어가 어려워 성능 한계에 도달하기 쉽습니다.</p>\n<br />\n<p>따라서 메시지 브로커가 일시적으로 데이터를 축적해야 합니다.</p>\n<br />\n<ul>\n<li><strong>메시지 브로커</strong></li>\n</ul>\n<p>데이터를 일시적으로 축적하는 중산층</p>\n<br />\n<p>빅데이터를 위한 <strong>분산형 메시지 브로커</strong>는 다음과 같습니다.</p>\n<br />\n<ul>\n<li><em>Apache Kafka</em></li>\n<li><em>Amazon Kinesis</em></li>\n</ul>\n<br />\n<ul>\n<li><strong>생산자</strong></li>\n</ul>\n<p>메시지 브로커에 데이터를 넣는(push) 것</p>\n<br />\n<ul>\n<li><strong>소비자</strong></li>\n</ul>\n<p>메시지 브로커로부터 데이터를 가져오는(pull) 것</p>\n<br />\n<p>메시지 브로커는 일정량의 데이터를 일정한 간격으로 분산 스토리지에 기록하여 성능 문제를 피할 수 있습니다.</p>\n<br />\n<ul>\n<li><strong>스트림 처리</strong></li>\n</ul>\n<p>짧은 간격으로 차례대로 데이터를 꺼내서 처리하는 것을 <em>스트림 처리</em>라고 합니다.</p>\n<br />\n<p>메시지 브로커로 부터 소비자에게로 초당 데이터를 보내는 것을 스트림 처리의 예시라고 볼 수 있죠.</p>\n<br />\n<ul>\n<li><strong>메시지 라우팅</strong></li>\n</ul>\n<p>메시지가 복사되어 데이터를 여러 분기시킬 수 있는 것을 말합니다.</p>\n<br />\n<p>일부의 데이터는 실시간으로, 일부의 데이터는 데이터 분석을 위한 분산 스토리지로 분기 시켜 보낼 수 있습니다.</p>\n<br />\n<h3 id=\"메시지-배송을-위한-세-가지-설계-방식\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%8B%9C%EC%A7%80-%EB%B0%B0%EC%86%A1%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%84%B8-%EA%B0%80%EC%A7%80-%EC%84%A4%EA%B3%84-%EB%B0%A9%EC%8B%9D\" aria-label=\"메시지 배송을 위한 세 가지 설계 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메시지 배송을 위한 세 가지 설계 방식</h3>\n<br />\n<p>성능 문제 외 중복이나 누락 등의 <strong>신뢰성</strong> 문제가 있습니다.</p>\n<br />\n<p>이런 경우 대부분 다음 중 하나의 설계 방식을 보장하도록 합니다.</p>\n<br />\n<ol>\n<li>at most once</li>\n</ol>\n<p>메시지는 한번만 전송. 하지만 전송 도중 실패할 수 있음(결손)</p>\n<br />\n<ol start=\"2\">\n<li>exactly once</li>\n</ol>\n<p>메시지는 손실되거나 중복 없이 한 번만 전달.</p>\n<br />\n<ol start=\"3\">\n<li>at least once</li>\n</ol>\n<p>메시지는 확실히 전달되나, 여러 번 전달될 수 있음(중복)</p>\n<br />\n<p>얼핏 보기에는 exactly once가 효율적으로 보이나, 이는 내부적으로 <strong>코디네이터</strong>라는 중계자를 사용합니다.</p>\n<br />\n<p>이 코디네이터를 통해서 exactly once를 실행하면 신뢰성은 어느정도 보장되나, 시간 지연 및 코디네이터에 대한 의존성이 높아져 이를 도입하지 않습니다.</p>\n<br />\n<p>오히려 at least once를 사용해 중복 제거는 사용자에게 맡기는 구조를 사용합니다.\r\n<br /></p>\n<p>특히 TCP/IP의 경우 TCP 패킷에 그것을 식별하는 시퀀스 번호가 포함되어 있어 중복 제거를 실행할 수 있습니다.</p>\n<br />\n<ul>\n<li>Apache Flume : at least once 보장</li>\n<li>Apache Kafka : at least once를 보장</li>\n<li>Logstash : at least once를 보장</li>\n<li>Fluentd : 옵션으로 at least once를 보장</li>\n</ul>\n<br />\n<h3 id=\"중복-제거\" style=\"position:relative;\"><a href=\"#%EC%A4%91%EB%B3%B5-%EC%A0%9C%EA%B1%B0\" aria-label=\"중복 제거 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>중복 제거</h3>\n<br />\n<p>TCP에서와 같이 모든 메시지에 시퀀스 번호를 붙히기엔 성능 향상 면에서 불필요합니다.</p>\n<br />\n<p>따라서 그 대안으로 여러 방법이 사용됩니다.</p>\n<br />\n<ol>\n<li><strong>오프셋을 이용한 중복 제거</strong></li>\n</ol>\n<br />\n<p>이 경우는 데이터의 파일 시작 위치 정보를 담은 작은 메시지를 담아서 보냅니다.</p>\n<br />\n<p>벌크 형 데이터 전송에는 이러한 방법을 사용하나, 스트리밍 형식의 메시지 배송에서는 거의 사용하지 않습니다.</p>\n<br />\n<ol start=\"2\">\n<li>고유 ID에 의한 중복 제거</li>\n</ol>\n<br />\n<p>모든 메시지에 UUID 등의 고유 ID를 지정해주는 방법입니다. 이 경우에는 중복의 가능성을 완전히 제거하지는 못하나, 최근에 받은 메시지의 중복도를 낮춤으로써 신뢰성을 향상시킵니다.(예를 들어 최근 1시간만 기억)</p>\n<br />\n<p>신뢰성 높은 메시지 전송을 위해서는 중간 경로를 모두 at least once로 통일한 후, 고유 ID를 통해 중복을 제거해야 합니다.</p>\n<br />\n<p>만약 중간 경로에 at most once가 존재한다면 결손의 가능성도 있기 때문입니다.</p>\n<br />\n<h4 id=\"고유-id를-통한-중간-제거의-방법\" style=\"position:relative;\"><a href=\"#%EA%B3%A0%EC%9C%A0-id%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%A4%91%EA%B0%84-%EC%A0%9C%EA%B1%B0%EC%9D%98-%EB%B0%A9%EB%B2%95\" aria-label=\"고유 id를 통한 중간 제거의 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>고유 ID를 통한 중간 제거의 방법</h4>\n<br />\n<ol>\n<li><strong>NoSQL 데이터베이스를 이용</strong></li>\n</ol>\n<p>Cassandra나 Elasticsearch 등은 특성상 데이터를 쓸 때 고유 ID를 지정하고 동일한 ID는 덮어써 중복을 없앱니다.</p>\n<br />\n<ol start=\"2\">\n<li><strong>SQL로 중복을 제거</strong></li>\n</ol>\n<p>보내온 데이터를 객체 스토리지에 저장한 후, 나중에 읽는 단계에서 중복을 제거하는 겁니다.</p>\n<br />\n<p>이는 대규모 데이터 처리이므로 메모리에서 처리하는 것이 불가능하며, Hive와 같은 배치형 쿼리 엔진을 통해 진행해야 합니다.</p>\n<br />\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">// DISTINCT를 통한 중복 제거</span>\r\n<span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DISTINCT</span> unique_id<span class=\"token punctuation\">,</span> col1<span class=\"token punctuation\">,</span> col2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// GROUP BY를 통한 중복 제거</span>\r\n<span class=\"token keyword\">SELECT</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>col1<span class=\"token punctuation\">)</span> col1<span class=\"token punctuation\">,</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>col2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> unique_id<span class=\"token punctuation\">;</span></code></pre></div>\n<br />\n<p>빅 데이터 시스템은 매우 높은 성능을 요구하기에 아주 작은 중복은 무시하는 경향이 있습니다.</p>\n<br />\n<p>그렇기에 멱등한 조작에 유의하여 중복이 있어도 문제가 되지 않는 시스템을 설계하는 것을 추천합니다.</p>\n<br />\n<p>따라서 신뢰성이 중시되는 경우에는 되도록 스트리밍 형식의 메시지 전송을 피하고, 벌크 형의 데이터 전송을 하여 중복/결손을 피해야합니다.</p>\n<br />\n<hr>\n<h3 id=\"시계열-데이터의-최적화\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B3%84%EC%97%B4-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%EC%B5%9C%EC%A0%81%ED%99%94\" aria-label=\"시계열 데이터의 최적화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시계열 데이터의 최적화</h3>\n<br />\n<ul>\n<li><strong>이벤트 시간</strong></li>\n</ul>\n<p>클라이언트 상에서 메시지가 생성된 시간</p>\n<ul>\n<li><strong>프로세스 시간</strong></li>\n</ul>\n<p>서버가 처리하는 시간</p>\n<br />\n<p>분석의 대상이 되는 것은 이 이벤트 시간입니다.</p>\n<br />\n<p>이벤트 시간과 프로세스 시간은 어느정도 차이가 존재합니다.</p>\n<br />\n<p>이벤트가 발생했다고 해서 그 날 바로 즉시 데이터가 배송되어 도착하는 것은 아닙니다.</p>\n<br />\n<p>일련의 처리과정을 거치고 도달한 시간인 프로세스 시간과 차이가 있죠.</p>\n<br />\n<p>즉, 이러한 문제를 해결하기 위해서 <strong>분산 스토리지에 저장하는 경우 프로세스 시간을 기준</strong>으로 구분합니다.</p>\n<br />\n<p>프로세스 시간동안 수집한 특정 이벤트 시간을 분석해야 하는 경우를 생각해봅시다.</p>\n<br />\n<p>그러기 위해서는 각 프로세스 시간 동안 존재하는 특정 이벤트 시간을 가져와야하죠.</p>\n<br />\n<p>원하는 특정 이벤트 시간은 따로 정렬되어 있지 않기에 우리는 각 프로세스 시간 파일을 뒤져가며 이벤트 시간을 찾아야 합니다.</p>\n<br />\n<p>이렇게 <strong>다수의 파일을 모두 검색하는 쿼리</strong>를 <strong>풀 스캔</strong>이라고 합니다.</p>\n<br />\n<p>굉장히 비효율적인 방법입니다. 이벤트 시간에 의한 집계를 효율적으로 바꿀 필요가 있습니다.</p>\n<br />\n<h3 id=\"시계열-인덱스\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B3%84%EC%97%B4-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-label=\"시계열 인덱스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시계열 인덱스</h3>\n<br />\n<p>이벤트 시간 취급을 효율화하기 위해 데이터를 정렬하는 것을 고려할때,</p>\n<p>이벤트 시간에 대해 인덱스 만드는 방법이 있습니다.</p>\n<br />\n<p>이 방법은 Cassandra(NoSQL)와 같은 시계열 인덱스에 대응하는 <strong>분산 데이터베이스</strong>를 사용하면 이벤트 시간으로 인덱스된 테이블을 얻을 수 있습니다.</p>\n<br />\n<p>일반적으로 Cassandra와 같은 NoSQL은 장기간 집계에 최적화 되있지 않습니다.</p>\n<br />\n<p>짧은 범위라면 빠르게 집계할 수 있으나, 열 지향 스토리지를 지속적으로 만들어 집계하는 것에 못미칩니다.</p>\n<br />\n<p>헷갈리면 안되는 것이 일반적인 분산 데이터베이스는 여러 곳으로 분산된 데이터베이스를 하나의 가상 시스템처럼 사용할 수 있는 데이터베이스를 의미합니다. NoSQL이라고 부르는 데이터베이스들은 분산 데이터베이스로 사용가능합니다.</p>\n<br />\n<h3 id=\"조건절-푸쉬다운\" style=\"position:relative;\"><a href=\"#%EC%A1%B0%EA%B1%B4%EC%A0%88-%ED%91%B8%EC%89%AC%EB%8B%A4%EC%9A%B4\" aria-label=\"조건절 푸쉬다운 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>조건절 푸쉬다운</h3>\n<br />\n<p>도착한 데이터를 배치 처리로 변환하는 것을 고려해봅시다.</p>\n<br />\n<p>우선 이벤트 시간으로 데이터를 정렬해줍니다.(RDB)</p>\n<br />\n<p>이후, 열 지향 스토리지로 변환하도록 합니다. 그렇게 되면 <em>칼럼 단위의 통계 정보</em>를 이용해 최적화가 이루어집니다.</p>\n<br />\n<p>즉, 원하는 이벤트 시간의 값이 어디있는지 알 수 있다는 겁니다. 정렬되어 있다는 이점을 이용해 해당 프로세스 시간 기간 당 이벤트 시간을 모두 탐색하지 않더라도 이벤트 시간을 찾을 수 있습니다.</p>\n<br />\n<p><strong>칼럼 단위의 통계 정보를 이용해 최소한의 데이터만을 읽는 최적화</strong>를 <strong>조건절 푸쉬다운</strong>이라고 합니다.</p>\n<br />\n<h3 id=\"이벤트-시간에-의한-분할\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%8B%9C%EA%B0%84%EC%97%90-%EC%9D%98%ED%95%9C-%EB%B6%84%ED%95%A0\" aria-label=\"이벤트 시간에 의한 분할 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이벤트 시간에 의한 분할</h3>\n<br />\n<p>데이터 검색을 더욱 효과적으로 하기 위해서는 앞서 진행한 조건절 푸쉬다운에 테이블 파이셔닝의 개념을 도입하면 됩니다.</p>\n<br />\n<p>앞서 분산 처리 시스템에서 팩트 테이블을 생성하는 때에 테이블 파티셔닝을 통해서 결손 및 중복 문제를 해결했음을 기억해봅시다.</p>\n<br />\n<p>마찬가지로 이벤트 시간을 기준으로 테이블 파티셔닝을 진행하여 분할합니다. 이때 생성된 테이블을 <strong>시계열 테이블</strong>이라고 합니다.</p>\n<br />\n<p>다만, 시간이 지날 수록 분산 스토리지에 대량의 작은 파일이 만들어져 쿼리 성능은 점차 악화됩니다. 작은 데이터를 효율적으로 사용할 수 있는 분산 데이터베이스를 사용하거나 버리는 아이디어가 필요합니다.</p>\n<br />\n<h3 id=\"데이터-마트를-이벤트-시간으로-정렬\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%A7%88%ED%8A%B8%EB%A5%BC-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%8B%9C%EA%B0%84%EC%9C%BC%EB%A1%9C-%EC%A0%95%EB%A0%AC\" aria-label=\"데이터 마트를 이벤트 시간으로 정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 마트를 이벤트 시간으로 정렬</h3>\n<br />\n<p>지금까지는 데이터 마트로 이동하기 이전, 집계 성능을 최적화 하기 위한 데이터 수집 방법에 대해 알아보았습니다.(데이터 수집부터 데이터 레이크까지)</p>\n<br />\n<p>하지만, 데이터 수집 단계에서 이벤트 시간을 따로 따지지 않고 프로세스 시간만을 이용하여 저장한 후, 데이터 마트를 만드는 과정에서 이벤트 시간에 대해 정렬을 합니다.</p>\n<br />\n<p>즉, 테이블 파티셔닝을 하지 않고, 조건절 푸쉬다운 상태에서 그대로 데이터 마트로 이동하여 정렬을 합니다.</p>\n<br />\n<p>그러면 파일이 조각나지않고, 최적의 상태를 유지합니다.</p>\n<br />\n<h3 id=\"nosql-데이터베이스에-의한-데이터-활용\" style=\"position:relative;\"><a href=\"#nosql-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%99%9C%EC%9A%A9\" aria-label=\"nosql 데이터베이스에 의한 데이터 활용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NoSQL 데이터베이스에 의한 데이터 활용</h3>\n<br />\n<p>분산 데이터베이스로써 사용할 수 있는 스토리지는 객체 스토리지 및 NoSQL이 있습니다.</p>\n<br />\n<p>객체 스토리지는 임의의 덩어리 파일을 저장할 수 있는 데이터베이스라고 배웠습니다.</p>\n<br />\n<p>하지만 객체 스토리지를 분산 데이터베이스로 사용하기에는 어느정도 단점이 존재합니다.</p>\n<br />\n<ol>\n<li>객체 스토리지 상의 파일은 교체가 어렵습니다.</li>\n</ol>\n<p>일단 써놓으면 그것을 통째로 바꾸는 방법밖에 없습니다.</p>\n<br />\n<ol start=\"2\">\n<li>객체 스토리지에 저장된 데이터를 집계하기까지 시간이 걸립니다.</li>\n</ol>\n<p>즉 실시간 집계(가령 시계열 DB를 만드는 경우)를 하는 때에 열 지향 스토리지로 만들어 집계하기 까지 시간이 너무 걸린다는 말입니다.</p>\n<br />\n<p>이를 위해 <strong>특정 용도에 최적화된 데이터 저장소</strong>를 일컬어 <strong>NoSQL 데이터베이스</strong>를 사용합니다.</p>\n<br />\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABaklEQVQ4y41Sa2+DMAzk///LbmqhLUkgrwKB3nRejVLWD7NkJbHPr3MaAHg+n6L1/T+q+FqaI8g5i8E5xBjR9z3GYYD3AeM4YhgGxBTlvpTypwFJiIPQsa0rtm2TeykFKSXxqU1PwR9im3mepdq6rhI8TfPupI826rIsgmEy1Xma5SyveOmQQSEEXLtOzmma8Hg8ZCwCvR/Rdp1QkHOGcw7fX184ny84X36V1LCgJCSI3JxOJ1yvN4QYJBGTMjnH9d7LSRuVbxZ35DRG8e0J2SoNBFDZsYqOxgI1+cQzEWPZDJPtSzmuvX7zvlRLqX1MxgmO+EbGyFkq8k4K2BWr8q3d6Fg6EW3G2J2KvUOCgvdoL61wo0vRBXEp1hrknKALJO5+74VzY40kLa9/2SjpXdvJBhmgXyamJB1rpzwZqB3Tx5PYNw6VDyWfwje36KwV4u+3mySi5JRhjJFG+L3eOMQHOS6qtn3y1fYfwOr5AUpFafIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"흐름.png\"\n        title=\"흐름.png\"\n        src=\"/static/eadd609bb3f01966b6c0fcb50b8a7e04/37523/%ED%9D%90%EB%A6%84.png\"\n        srcset=\"/static/eadd609bb3f01966b6c0fcb50b8a7e04/e9ff0/%ED%9D%90%EB%A6%84.png 180w,\n/static/eadd609bb3f01966b6c0fcb50b8a7e04/f21e7/%ED%9D%90%EB%A6%84.png 360w,\n/static/eadd609bb3f01966b6c0fcb50b8a7e04/37523/%ED%9D%90%EB%A6%84.png 720w,\n/static/eadd609bb3f01966b6c0fcb50b8a7e04/8bd7c/%ED%9D%90%EB%A6%84.png 845w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>정리해서 흐름을 한번 살펴 봅시다.</p>\n<br />\n<p>우선 스트림 처리의 경우 시계열 DB를 만들어 바로 활용할 수 있는 구조입니다.(이벤트 시간으로 구성된 파티션 집합)\r\n여기서 쿼리엔진을 통해 사용할 수 있는 것이죠.</p>\n<br />\n<p>우리는 분산 스토리지로 객체 스토리지를 사용하여 하둡 및 스파크 등 분산 처리 시스템을 통해 열지향 DB로 바꾼 후, 집계를 실시했습니다.</p>\n<br />\n<p>하지만, 짧은 범위의 빠른 집계 및 고속 검색을 위해서는 이런 객체 스토리지를 사용하는 것보다 NoSQL을 사용함으로써, 용도에 맞게 바로 기록하고 활용할 수 있다는 겁니다.</p>\n<br />\n<p>NoSQL의 예로 <em>분산 KVS</em>, <em>와이드 칼럼 스토어</em>, <em>도큐먼트 스토어</em>, <em>검색 엔진</em> 등이 있습니다.</p>\n<br />\n<ul>\n<li>분산 KVS : 디스크 쓰기 속도를 높임</li>\n<li>와이드 칼럼 스토어 : 구조화 데이터를 분석해서 저장함</li>\n<li>도큐먼트 스토어 : 스키마리스 데이터 관리</li>\n<li>검색 엔진 : 키워드 검색으로 데이터 검색</li>\n</ul>\n<hr>\n<h3 id=\"분산-kvs\" style=\"position:relative;\"><a href=\"#%EB%B6%84%EC%82%B0-kvs\" aria-label=\"분산 kvs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>분산 KVS</h3>\n<p>모든 데이터를 키값 쌍으로 저장하도록 설계된 데이터 저장소를 말합니다.</p>\n<br />\n<p>객체 스토리지도 넓은 의미에서는 분산 KVS의 일종이나 여기서는 좀더 ‘작은 데이터’를 가정합니다.</p>\n<br />\n<p>구체적으로 몇 kb정도의 데이터를 초당 수만 번 읽고 쓰는 정도입니다.</p>\n<br />\n<p>분산 KVS는 모든 데이터에 <strong>고유의 키</strong>를 지정한 후, 부하 분산을 실시합니다.</p>\n<br />\n<p>아키텍처에 대한 예시는 다음과 같습니다.</p>\n<br />\n<ol>\n<li>마스터/슬레이브 형</li>\n</ol>\n<p>1대의 마스터가 전체를 관리합니다. 마스터가 중지하면 아무도 데이터를 읽고 쓸 수 없습니다.</p>\n<br />\n<ol start=\"2\">\n<li>p2p형 시스템</li>\n</ol>\n<p>모든 노드가 대등한 관계이므로 어떤 노드에 연결해도 데이터를 읽을 수 있습니다.</p>\n<br />\n<ul>\n<li><strong>Amazon DynamoDB</strong></li>\n</ul>\n<br />\n<p>항상 안정된 읽기 쓰기 성능을 제공하도록 디자인된 NoSQL 데이터베이스로 하나 또는 두 개의 키에 연결하는 형태로 임의의 스키마리스 데이터를 저장할 수 있습니다.</p>\n<br />\n<p>DynamoDB는 P2P형의 분산 아키텍처를 가지고 있습니다. DynamoDB에서는 사용자 수에 따라 노드의 수를 조절할 수 있어 성능 향상에 있어 유리합니다.</p>\n<br />\n<p>데이터 분석 방법은 다음과 가가습니다.</p>\n<br />\n<ol>\n<li>Amazon EMR과 결합하여 Hive에 의한 배치 처리를 진행합니다.</li>\n</ol>\n<br />\n<ol start=\"2\">\n<li>Amazon Redshift와 결합하여 데이터 웨어하우스에 데이터를 저장합니다.</li>\n</ol>\n<br />\n<ol start=\"3\">\n<li>DynamoDB 고유 기능인 Dynamo Streams를 통해 외부로 실시간 스트림 처리가 가능합니다.</li>\n</ol>\n<br />\n<h3 id=\"와이드-칼럼-스토어\" style=\"position:relative;\"><a href=\"#%EC%99%80%EC%9D%B4%EB%93%9C-%EC%B9%BC%EB%9F%BC-%EC%8A%A4%ED%86%A0%EC%96%B4\" aria-label=\"와이드 칼럼 스토어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>와이드 칼럼 스토어</h3>\n<br />\n<p>분산 KVS에서 발전시켜 2개 이상의 임의의 키에 데이터를 저장할 수 있도록 한 것이 <strong>와이드 칼럼 스토어</strong>입니다.</p>\n<br />\n<p>Google Cloud Bigtable, Apache Hbase, Apache Cassandra 가 대표적입니다.</p>\n<br />\n<p>내부적으로는 행만이 아니라 칼럼도 계속 증가합니다.</p>\n<br />\n<p>즉, 하나의 키에 대해서 여러개의 value를 확장시킬 수 있다는 뜻이 됩니다.</p>\n<br />\n<ul>\n<li><strong>Cassandra</strong></li>\n</ul>\n<br />\n<p>CQL이라는 쿼리 언어를 통해서 구조화 데이터를 취급할 수 있습니다.</p>\n<br />\n<p>p2p 형의 분산 아키텍처를 가지고 있습니다. 또한 거대한 데이터 테이블을 복합키를 이용해 관리합니다.</p>\n<br />\n<p>와이드 칼럼 스토어는 데이터 집계에 있어 적합하지 않습니다.</p>\n<br />\n<p>집계를 위해서는 분산 처리 시스템을 거쳐야 합니다. Hive, Presto, Spark등의 쿼리 엔진은 이에 대응하고 있습니다.</p>\n<br />\n<h3 id=\"도큐먼트-스토어\" style=\"position:relative;\"><a href=\"#%EB%8F%84%ED%81%90%EB%A8%BC%ED%8A%B8-%EC%8A%A4%ED%86%A0%EC%96%B4\" aria-label=\"도큐먼트 스토어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도큐먼트 스토어</h3>\n<br />\n<p>도큐먼트 스토어는 <strong>성능 향상</strong>의 목표 보단 <strong>데이터 처리의 유연성</strong>을 목적으로 합니다.</p>\n<br />\n<p>구체적으로는 스키마리스 데이터를 그대로 저장하고 쿼리를 실행할 수 있다는 것이죠.</p>\n<br />\n<p>물론 간단한 KVS의 경우에도 JSON 텍스트로 저장할 수 있으나 복잡한 쿼리를 실행할 수는 없습니다.</p>\n<br />\n<p>도큐먼트 스토어의 장점은 스키마를 정하지 않고 데이터를 처리할 수 있습니다.</p>\n<br />\n<ul>\n<li><strong>MongoDB</strong></li>\n</ul>\n<br />\n<p>MongoDB는 오픈 소스의 분산형 도큐먼트 스토어로 자바스크립트와 같은 프로그래밍 언어로 데이터를 읽고 쓸 수 있습니다.</p>\n<br />\n<p>간편함 덕분에 그 인기가 높습니다.</p>\n<br />\n<p>MongoDB도 여러 노드에 데이터를 분산할 수 있으나, 그 자체는 역시 대량의 데이터를 집계하는데 적합하지 않습니다.</p>\n<br />\n<h3 id=\"검색-엔진\" style=\"position:relative;\"><a href=\"#%EA%B2%80%EC%83%89-%EC%97%94%EC%A7%84\" aria-label=\"검색 엔진 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>검색 엔진</h3>\n<br />\n<p>NoSQL 데이터베이스와는 조금 성격이 다르지만, 저장된 데이터를 쿼리로 찾아낸다는 점에서 유사한 부분이 많고, 텍스트 데이터 및 스키마리스 데이터를 집계하는데 자주 사용됩니다.</p>\n<br />\n<p>특징은 텍스트 데이터를 전문 탐색하기 위해 역 색인을 만든다는 것입니다.</p>\n<br />\n<blockquote>\n<p>역 색인 : 텍스트에 포함된 단어를 분해하고 어떤 단어가 어떤 레코드에 포함되어 있는가 하는 인덱스를 먼저 만들어 검색을 고속화</p>\n</blockquote>\n<br />\n<p>대부분의 NoSQL은 성능 향상을 위해 색인 작성을 제한하는 경우가 많으나, 대조적으로 검색 엔진은 색인을 만듦으로써 데이터를 찾는 것에 특화되어 있습니다.</p>\n<br />\n<p>즉, 검색 엔진은 데이터 축적보단 실시간 집계 시스템의 일부로 이용합니다.</p>\n<br />\n<p>흐름에서 보았던 스트림 데이터 수집 이후 메시지 브로커를 통해 분산 스토리지로 가서 분산 처리 시스템을 거친 후, 데이터 마트를 만드는 것이 아닌 <strong>메시지 브로커</strong>에서 바로 <strong>검색 엔진</strong>으로 이동하여 실시간성이 높은 검색 도구를 만드는데 사용됩니다.</p>\n<br />\n<ul>\n<li><strong>Elasticssearch</strong></li>\n</ul>\n<br />\n<p>오픈 소스의 검섹 엔진으로써 인기가 많은 것은 Elasticssearch입니다.</p>\n<br />\n<p>로그 수집 소프트웨어인 <em>Logstash</em>, 시각화 소프트웨어인 <em>Kibana</em>와 함께 ELK 스택 또는 Elastic 스택으로 자주 이용됩니다.</p>\n<br />\n<p>Elasticsearch는 임의의 JSON 데이터를 저장할 수 있어 도큐먼트 스토어와 비슷하나 아무것도 지정하지 않으면 모든 필드에 색인을 만듭니다.</p>\n<br />\n<p>텍스트 데이터에서는 역 색인을 구축하기에 쓰기에 부하가 크고, 필요에 따라 색인을 무효화 시키기 위해 색인을 무효화 합니다.</p>\n<br />\n<p>자체 쿼리 언어에 의한 고급 집계 기능을 가지고 있습니다. 열 지향 스토리지에 대응하여 데이터 집계에 힘을 더해줍니다.</p>\n<br />\n<p>다만 표준 쿼리 언어가 복잡해서 Kibana와 같은 프론트엔드를 사용하거나 프로그램 안에서 호출합니다.</p>\n<br />\n<ul>\n<li><strong>Splunk</strong></li>\n</ul>\n<br />\n<p>오픈 소스는 아니지만 상용 검섹 엔진 Splunk도 텍스트 데이터를 집계하기 위한 도구로 알려져 있습니다.</p>\n<br />\n<p>자신하는 분야는 비정형 데이터, 즉 스키마리스 데이터/비구조화 데이터입니다.</p>\n<br />\n<p>특징은 검색할 때마다 데이터가 구조화 되어서 테이블을 만들 수 있다는 것입니다.</p>\n<br />\n<h3 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h3>\n<br />\n<p>데이터를 모아서 분산 스토리지에 저장하기 까지의 데이터 수집의 흐름을 알아보았습니다.</p>\n<br />\n<p>집계 효율을 고려했을 때, 스트리밍 형은 배치 형에 비해 집계 효율이 떨어집니다.</p>\n<br />\n<p>따라서 메세지 배송 방식을 통해 메시지 브로커를 도입하여 분산 스토리지에 쓰는 속도를 안정화 했으며 경로를 라우팅하여 데이터를 스트리밍 처리 혹은 배치 처리 모두 사용할 수 있게 되었습니다.</p>\n<br />\n<p>전자의 경우 실시간 집계에 뛰어난 시계열 DB로 바로 만듭니다. 데이터 마트를 만드는 과정에서도 시계열 DB를 만들기도 합니다.</p>\n<br />\n<p>후자의 경우 대량 데이터 집계를 할 때 주로 배치처리를 함으로 Hive와 같은 쿼리 엔진으로 열 지향 DB로 만들어 줍니다.</p>\n<br />\n<p>시계열 인덱스 사용, 조건절 푸쉬 다운(정렬 후 열 지향으로 풀 스캔 피하기), 테이블 파티셔닝, 이벤트 시간에 대한 정렬을 데이터 마트 만들 때 실시하는 등으로 스트림 처리를 최적화합니다.</p>\n<br />\n<p>메시지 전송에서는 중복과 누락의 가능성이 있기에 일반적으로 at least once를 통해 중복을 어는 정도 허용한 후, 나중에 중복 데이터를 제거합니다.</p>\n<br />\n<p>기본적으로 Amazon S3, Hadoop HDFS와 같은 객체 스토리지를 분산 스토리지로 사용하나, 특정 용도에 최적화된 NoSQL을 사용하기도 합니다.</p>\n<br />\n<p>NoSQL 데이터베이스와 같은 분산 스토리지에 데이터를 쓰는 경우 읽기 및 쓰기 성능은 우수하나, 대량의 데이터를 집계하기에는 쿼리 엔진과 연결하여 애드 훅 분석을 하거나 장기적인 분석을 위한 데이터 웨어하우스를 구축해야 합니다.</p>\n<br />\n<p>검색 엔진의 경우 스트림 처리 이후 검색 엔진에서 실시간 집계 및 검색 도구로 사용될 수 있습니다.</p>\n<br />","frontmatter":{"date":"February 16, 2023","title":"빅 데이터를 지탱하는 기술 책 리뷰 - (3)","categories":"Engineer","author":"DEVEL","emoji":"🦊"},"fields":{"slug":"/data-engineer-4/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://hsjni0110.github.io/devel-repo","comments":{"utterances":{"repo":"hsjni0110/hsjni0110.github.io"}}}}},"pageContext":{"slug":"/data-engineer-5/","nextSlug":"/data-engineer-4/","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}